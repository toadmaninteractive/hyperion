// Author: Igor compiler
// Compiler version: igorc 2.1.1
// DO NOT EDIT THIS FILE - it is machine generated

import * as Igor from './igor';

export enum TestRunOrderBy {
    Id = 1,
    Status = 2,
    CreatedAt = 3,
    UpdatedAt = 4,
    StartedAt = 5,
    FinishedAt = 6,
}

export namespace TestRunOrderBy {
    export function toJson(value: TestRunOrderBy): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): TestRunOrderBy {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: TestRunOrderBy): Igor.Json.JsonValue {
        switch (value) {
            case TestRunOrderBy.Id: return 'id';
            case TestRunOrderBy.Status: return 'status';
            case TestRunOrderBy.CreatedAt: return 'created_at';
            case TestRunOrderBy.UpdatedAt: return 'updated_at';
            case TestRunOrderBy.StartedAt: return 'started_at';
            case TestRunOrderBy.FinishedAt: return 'finished_at';
            default: throw new Error(`Invalid TestRunOrderBy value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): TestRunOrderBy {
        switch (json) {
            case 'id': return TestRunOrderBy.Id;
            case 'status': return TestRunOrderBy.Status;
            case 'created_at': return TestRunOrderBy.CreatedAt;
            case 'updated_at': return TestRunOrderBy.UpdatedAt;
            case 'started_at': return TestRunOrderBy.StartedAt;
            case 'finished_at': return TestRunOrderBy.FinishedAt;
            default: throw new Error(`Invalid TestRunOrderBy value: ${json}`);
        }
    }
}

export class CreateTestRunRequest {
    title?: string | null = null;

    static fromJson(json: Igor.Json.JsonValue): CreateTestRunRequest {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new CreateTestRunRequest();
        obj.title = ('title' in jsonObject && jsonObject['title'] != null) ? jsonObject['title'] as string : null;
        return obj;
    }

    static toJson(value: CreateTestRunRequest): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        if (value.title != null) result['title'] = value.title;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return CreateTestRunRequest.toJson(this);
    }
}

export enum CreateTestRunError {
    ProjectNotExists = 1,
    TitleAlreadyExists = 2,
}

export namespace CreateTestRunError {
    export function toJson(value: CreateTestRunError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): CreateTestRunError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: CreateTestRunError): Igor.Json.JsonValue {
        switch (value) {
            case CreateTestRunError.ProjectNotExists: return 'project_not_exists';
            case CreateTestRunError.TitleAlreadyExists: return 'title_already_exists';
            default: throw new Error(`Invalid CreateTestRunError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): CreateTestRunError {
        switch (json) {
            case 'project_not_exists': return CreateTestRunError.ProjectNotExists;
            case 'title_already_exists': return CreateTestRunError.TitleAlreadyExists;
            default: throw new Error(`Invalid CreateTestRunError value: ${json}`);
        }
    }
}

export enum StartTestRunError {
    AlreadyStarted = 1,
    AlreadyClosed = 2,
}

export namespace StartTestRunError {
    export function toJson(value: StartTestRunError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): StartTestRunError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: StartTestRunError): Igor.Json.JsonValue {
        switch (value) {
            case StartTestRunError.AlreadyStarted: return 'already_started';
            case StartTestRunError.AlreadyClosed: return 'already_closed';
            default: throw new Error(`Invalid StartTestRunError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): StartTestRunError {
        switch (json) {
            case 'already_started': return StartTestRunError.AlreadyStarted;
            case 'already_closed': return StartTestRunError.AlreadyClosed;
            default: throw new Error(`Invalid StartTestRunError value: ${json}`);
        }
    }
}

export enum CloseTestRunError {
    AlreadyClosed = 1,
}

export namespace CloseTestRunError {
    export function toJson(value: CloseTestRunError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): CloseTestRunError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: CloseTestRunError): Igor.Json.JsonValue {
        switch (value) {
            case CloseTestRunError.AlreadyClosed: return 'already_closed';
            default: throw new Error(`Invalid CloseTestRunError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): CloseTestRunError {
        switch (json) {
            case 'already_closed': return CloseTestRunError.AlreadyClosed;
            default: throw new Error(`Invalid CloseTestRunError value: ${json}`);
        }
    }
}

export enum ReopenTestRunError {
    NotClosed = 1,
}

export namespace ReopenTestRunError {
    export function toJson(value: ReopenTestRunError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): ReopenTestRunError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: ReopenTestRunError): Igor.Json.JsonValue {
        switch (value) {
            case ReopenTestRunError.NotClosed: return 'not_closed';
            default: throw new Error(`Invalid ReopenTestRunError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): ReopenTestRunError {
        switch (json) {
            case 'not_closed': return ReopenTestRunError.NotClosed;
            default: throw new Error(`Invalid ReopenTestRunError value: ${json}`);
        }
    }
}

export enum CloneTestRunError {
    ProjectNotExists = 1,
    TitleAlreadyExists = 2,
}

export namespace CloneTestRunError {
    export function toJson(value: CloneTestRunError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): CloneTestRunError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: CloneTestRunError): Igor.Json.JsonValue {
        switch (value) {
            case CloneTestRunError.ProjectNotExists: return 'project_not_exists';
            case CloneTestRunError.TitleAlreadyExists: return 'title_already_exists';
            default: throw new Error(`Invalid CloneTestRunError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): CloneTestRunError {
        switch (json) {
            case 'project_not_exists': return CloneTestRunError.ProjectNotExists;
            case 'title_already_exists': return CloneTestRunError.TitleAlreadyExists;
            default: throw new Error(`Invalid CloneTestRunError value: ${json}`);
        }
    }
}

export class UpdateTestRunRequest {
    title?: string | null;

    static fromJson(json: Igor.Json.JsonValue): UpdateTestRunRequest {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new UpdateTestRunRequest();
        if (jsonObject['title'] !== undefined) obj.title = jsonObject['title'] as string;
        return obj;
    }

    static toJson(value: UpdateTestRunRequest): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        if (value.title !== undefined) result['title'] = value.title;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return UpdateTestRunRequest.toJson(this);
    }
}

export enum UpdateTestRunError {
    TitleAlreadyExists = 1,
}

export namespace UpdateTestRunError {
    export function toJson(value: UpdateTestRunError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): UpdateTestRunError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: UpdateTestRunError): Igor.Json.JsonValue {
        switch (value) {
            case UpdateTestRunError.TitleAlreadyExists: return 'title_already_exists';
            default: throw new Error(`Invalid UpdateTestRunError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): UpdateTestRunError {
        switch (json) {
            case 'title_already_exists': return UpdateTestRunError.TitleAlreadyExists;
            default: throw new Error(`Invalid UpdateTestRunError value: ${json}`);
        }
    }
}

export class CreateTestRunItemRequest {
    caseId!: number;
    orderNum!: number;

    static fromJson(json: Igor.Json.JsonValue): CreateTestRunItemRequest {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new CreateTestRunItemRequest();
        obj.caseId = jsonObject['case_id'] as number;
        obj.orderNum = jsonObject['order_num'] as number;
        return obj;
    }

    static toJson(value: CreateTestRunItemRequest): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['case_id'] = value.caseId;
        result['order_num'] = value.orderNum;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return CreateTestRunItemRequest.toJson(this);
    }
}

export enum CreateTestRunItemError {
    TestRunNotExists = 1,
    TestCaseNotExists = 2,
    ReporterNotExists = 3,
}

export namespace CreateTestRunItemError {
    export function toJson(value: CreateTestRunItemError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): CreateTestRunItemError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: CreateTestRunItemError): Igor.Json.JsonValue {
        switch (value) {
            case CreateTestRunItemError.TestRunNotExists: return 'test_run_not_exists';
            case CreateTestRunItemError.TestCaseNotExists: return 'test_case_not_exists';
            case CreateTestRunItemError.ReporterNotExists: return 'reporter_not_exists';
            default: throw new Error(`Invalid CreateTestRunItemError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): CreateTestRunItemError {
        switch (json) {
            case 'test_run_not_exists': return CreateTestRunItemError.TestRunNotExists;
            case 'test_case_not_exists': return CreateTestRunItemError.TestCaseNotExists;
            case 'reporter_not_exists': return CreateTestRunItemError.ReporterNotExists;
            default: throw new Error(`Invalid CreateTestRunItemError value: ${json}`);
        }
    }
}

export class UpdateTestRunItemRequest {
    summary?: string | null;
    orderNum!: number;
    jiraIssueKey?: string | null;

    static fromJson(json: Igor.Json.JsonValue): UpdateTestRunItemRequest {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new UpdateTestRunItemRequest();
        if (jsonObject['summary'] !== undefined) obj.summary = jsonObject['summary'] as string;
        if (jsonObject['order_num'] !== undefined) obj.orderNum = jsonObject['order_num'] as number;
        if (jsonObject['jira_issue_key'] !== undefined) obj.jiraIssueKey = jsonObject['jira_issue_key'] as string;
        return obj;
    }

    static toJson(value: UpdateTestRunItemRequest): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        if (value.summary !== undefined) result['summary'] = value.summary;
        if (value.orderNum !== undefined) result['order_num'] = value.orderNum;
        if (value.jiraIssueKey !== undefined) result['jira_issue_key'] = value.jiraIssueKey;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return UpdateTestRunItemRequest.toJson(this);
    }
}

export enum UpdateTestRunItemError {
    NothingToUpdate = 1,
}

export namespace UpdateTestRunItemError {
    export function toJson(value: UpdateTestRunItemError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): UpdateTestRunItemError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: UpdateTestRunItemError): Igor.Json.JsonValue {
        switch (value) {
            case UpdateTestRunItemError.NothingToUpdate: return 'nothing_to_update';
            default: throw new Error(`Invalid UpdateTestRunItemError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): UpdateTestRunItemError {
        switch (json) {
            case 'nothing_to_update': return UpdateTestRunItemError.NothingToUpdate;
            default: throw new Error(`Invalid UpdateTestRunItemError value: ${json}`);
        }
    }
}

export enum StartTestRunItemError {
    AlreadyStarted = 1,
    AlreadyFinished = 2,
    AssigneeNotExists = 3,
}

export namespace StartTestRunItemError {
    export function toJson(value: StartTestRunItemError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): StartTestRunItemError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: StartTestRunItemError): Igor.Json.JsonValue {
        switch (value) {
            case StartTestRunItemError.AlreadyStarted: return 'already_started';
            case StartTestRunItemError.AlreadyFinished: return 'already_finished';
            case StartTestRunItemError.AssigneeNotExists: return 'assignee_not_exists';
            default: throw new Error(`Invalid StartTestRunItemError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): StartTestRunItemError {
        switch (json) {
            case 'already_started': return StartTestRunItemError.AlreadyStarted;
            case 'already_finished': return StartTestRunItemError.AlreadyFinished;
            case 'assignee_not_exists': return StartTestRunItemError.AssigneeNotExists;
            default: throw new Error(`Invalid StartTestRunItemError value: ${json}`);
        }
    }
}

export class FinishTestRunItemRequest {
    summary?: string | null = null;

    static fromJson(json: Igor.Json.JsonValue): FinishTestRunItemRequest {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new FinishTestRunItemRequest();
        obj.summary = ('summary' in jsonObject && jsonObject['summary'] != null) ? jsonObject['summary'] as string : null;
        return obj;
    }

    static toJson(value: FinishTestRunItemRequest): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        if (value.summary != null) result['summary'] = value.summary;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return FinishTestRunItemRequest.toJson(this);
    }
}

export enum FinishTestRunItemError {
    AlreadyFinished = 1,
    AssigneeNotExists = 2,
}

export namespace FinishTestRunItemError {
    export function toJson(value: FinishTestRunItemError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): FinishTestRunItemError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: FinishTestRunItemError): Igor.Json.JsonValue {
        switch (value) {
            case FinishTestRunItemError.AlreadyFinished: return 'already_finished';
            case FinishTestRunItemError.AssigneeNotExists: return 'assignee_not_exists';
            default: throw new Error(`Invalid FinishTestRunItemError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): FinishTestRunItemError {
        switch (json) {
            case 'already_finished': return FinishTestRunItemError.AlreadyFinished;
            case 'assignee_not_exists': return FinishTestRunItemError.AssigneeNotExists;
            default: throw new Error(`Invalid FinishTestRunItemError value: ${json}`);
        }
    }
}

export class BlockTestRunItemRequest {
    failedSetupId!: number;
    setupParameterValue?: string | null = null;
    summary?: string | null = null;

    static fromJson(json: Igor.Json.JsonValue): BlockTestRunItemRequest {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new BlockTestRunItemRequest();
        obj.failedSetupId = jsonObject['failed_setup_id'] as number;
        obj.setupParameterValue = ('setup_parameter_value' in jsonObject && jsonObject['setup_parameter_value'] != null) ? jsonObject['setup_parameter_value'] as string : null;
        obj.summary = ('summary' in jsonObject && jsonObject['summary'] != null) ? jsonObject['summary'] as string : null;
        return obj;
    }

    static toJson(value: BlockTestRunItemRequest): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['failed_setup_id'] = value.failedSetupId;
        if (value.setupParameterValue != null) result['setup_parameter_value'] = value.setupParameterValue;
        if (value.summary != null) result['summary'] = value.summary;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return BlockTestRunItemRequest.toJson(this);
    }
}

export enum BlockTestRunItemError {
    AlreadyFinished = 1,
    AssigneeNotExists = 2,
    SetupNotExists = 3,
}

export namespace BlockTestRunItemError {
    export function toJson(value: BlockTestRunItemError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): BlockTestRunItemError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: BlockTestRunItemError): Igor.Json.JsonValue {
        switch (value) {
            case BlockTestRunItemError.AlreadyFinished: return 'already_finished';
            case BlockTestRunItemError.AssigneeNotExists: return 'assignee_not_exists';
            case BlockTestRunItemError.SetupNotExists: return 'setup_not_exists';
            default: throw new Error(`Invalid BlockTestRunItemError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): BlockTestRunItemError {
        switch (json) {
            case 'already_finished': return BlockTestRunItemError.AlreadyFinished;
            case 'assignee_not_exists': return BlockTestRunItemError.AssigneeNotExists;
            case 'setup_not_exists': return BlockTestRunItemError.SetupNotExists;
            default: throw new Error(`Invalid BlockTestRunItemError value: ${json}`);
        }
    }
}

export enum ReopenTestRunItemError {
    AlreadyOpened = 1,
    AssigneeNotExists = 2,
}

export namespace ReopenTestRunItemError {
    export function toJson(value: ReopenTestRunItemError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): ReopenTestRunItemError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: ReopenTestRunItemError): Igor.Json.JsonValue {
        switch (value) {
            case ReopenTestRunItemError.AlreadyOpened: return 'already_opened';
            case ReopenTestRunItemError.AssigneeNotExists: return 'assignee_not_exists';
            default: throw new Error(`Invalid ReopenTestRunItemError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): ReopenTestRunItemError {
        switch (json) {
            case 'already_opened': return ReopenTestRunItemError.AlreadyOpened;
            case 'assignee_not_exists': return ReopenTestRunItemError.AssigneeNotExists;
            default: throw new Error(`Invalid ReopenTestRunItemError value: ${json}`);
        }
    }
}
