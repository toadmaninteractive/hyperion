// Author: Igor compiler
// Compiler version: igorc 2.1.1
// DO NOT EDIT THIS FILE - it is machine generated

import { Injectable } from '@angular/core';
import { HttpClient, HttpErrorResponse, HttpHeaders } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { map, catchError } from 'rxjs/operators';
import * as Igor from './igor';
import * as DataProtocol from './data-protocol.data';
import * as DbProtocol from './db-protocol.data';
import * as TestRunProtocol from './test-run-protocol.data';
import * as CommonProtocol from './common-protocol.data';

@Injectable({
    providedIn: 'root',
})
export class HyperionTestRunService {
    public baseUrl = '';

    constructor(private http: HttpClient) { }

    public getTestRuns(projectId: number, orderBy: TestRunProtocol.TestRunOrderBy, orderDir: DataProtocol.OrderDirection, offset: number, limit: number, status: DbProtocol.TestRunStatus | null = null): Observable<DataProtocol.CollectionSlice<DbProtocol.TestRun>> {
        const queryParams: Array<string> = [];
        queryParams.push(`order_by=${TestRunProtocol.TestRunOrderBy.toJson(orderBy)}`);
        queryParams.push(`order_dir=${DataProtocol.OrderDirection.toJson(orderDir)}`);
        queryParams.push(`offset=${offset}`);
        queryParams.push(`limit=${limit}`);
        if (status != null)
            queryParams.push(`status=${status != null ? DbProtocol.TestRunStatus.toJson(status) : null}`);
        const queryString = queryParams.length > 0 ? `?${queryParams.join('&')}` : '';

        return this.http
            .get(`${this.baseUrl}/api/test/runs/project/${projectId}${queryString}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DataProtocol.CollectionSlice.instanceJsonSerializer<DbProtocol.TestRun>(DbProtocol.TestRun).fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getTestRun(id: number): Observable<DbProtocol.TestRun> {
        return this.http
            .get(`${this.baseUrl}/api/test/runs/${id}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(DataProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DbProtocol.TestRun.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public createTestRun(request: TestRunProtocol.CreateTestRunRequest, projectId: number): Observable<DbProtocol.TestRun> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .post(`${this.baseUrl}/api/test/runs/new/${projectId}`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 400: return throwError(DataProtocol.BadRequestError.instanceJsonSerializer<TestRunProtocol.CreateTestRunError>(TestRunProtocol.CreateTestRunError).fromJson(response.error));
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DbProtocol.TestRun.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public startTestRun(request: CommonProtocol.Empty, id: number): Observable<DbProtocol.TestRun> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .put(`${this.baseUrl}/api/test/runs/${id}/start`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 400: return throwError(DataProtocol.BadRequestError.instanceJsonSerializer<TestRunProtocol.StartTestRunError>(TestRunProtocol.StartTestRunError).fromJson(response.error));
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(DataProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DbProtocol.TestRun.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public closeTestRun(request: CommonProtocol.Empty, id: number): Observable<DbProtocol.TestRun> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .put(`${this.baseUrl}/api/test/runs/${id}/close`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 400: return throwError(DataProtocol.BadRequestError.instanceJsonSerializer<TestRunProtocol.CloseTestRunError>(TestRunProtocol.CloseTestRunError).fromJson(response.error));
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(DataProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DbProtocol.TestRun.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public reopenTestRun(request: CommonProtocol.Empty, id: number): Observable<DbProtocol.TestRun> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .put(`${this.baseUrl}/api/test/runs/${id}/reopen`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 400: return throwError(DataProtocol.BadRequestError.instanceJsonSerializer<TestRunProtocol.ReopenTestRunError>(TestRunProtocol.ReopenTestRunError).fromJson(response.error));
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(DataProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DbProtocol.TestRun.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public cloneTestRun(request: CommonProtocol.Empty, id: number): Observable<DbProtocol.TestRun> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .put(`${this.baseUrl}/api/test/runs/${id}/clone`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 400: return throwError(DataProtocol.BadRequestError.instanceJsonSerializer<TestRunProtocol.CloneTestRunError>(TestRunProtocol.CloneTestRunError).fromJson(response.error));
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(DataProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DbProtocol.TestRun.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public updateTestRun(request: TestRunProtocol.UpdateTestRunRequest, id: number): Observable<DbProtocol.TestRun> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .put(`${this.baseUrl}/api/test/runs/${id}`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 400: return throwError(DataProtocol.BadRequestError.instanceJsonSerializer<TestRunProtocol.UpdateTestRunError>(TestRunProtocol.UpdateTestRunError).fromJson(response.error));
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(DataProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DbProtocol.TestRun.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public deleteTestRun(id: number): Observable<DataProtocol.GenericResponse> {
        return this.http
            .delete(`${this.baseUrl}/api/test/runs/${id}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(DataProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DataProtocol.GenericResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getTestRunItems(runId: number): Observable<DataProtocol.Collection<DbProtocol.TestRunItem>> {
        return this.http
            .get(`${this.baseUrl}/api/test/run-items/run/${runId}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DataProtocol.Collection.instanceJsonSerializer<DbProtocol.TestRunItem>(DbProtocol.TestRunItem).fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getTestRunItem(id: number): Observable<DbProtocol.TestRunItem> {
        return this.http
            .get(`${this.baseUrl}/api/test/run-items/${id}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(DataProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DbProtocol.TestRunItem.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public createTestRunItems(request: TestRunProtocol.CreateTestRunItemRequest, runId: number): Observable<DataProtocol.Collection<DbProtocol.TestRunItem>> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .post(`${this.baseUrl}/api/test/run-items/new/${runId}`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 400: return throwError(DataProtocol.BadRequestError.instanceJsonSerializer<TestRunProtocol.CreateTestRunItemError>(TestRunProtocol.CreateTestRunItemError).fromJson(response.error));
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DataProtocol.Collection.instanceJsonSerializer<DbProtocol.TestRunItem>(DbProtocol.TestRunItem).fromJson(response as Igor.Json.JsonValue))
            );
    }

    public updateTestRunItem(request: TestRunProtocol.UpdateTestRunItemRequest, id: number): Observable<DbProtocol.TestRunItem> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .put(`${this.baseUrl}/api/test/run-items/${id}`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 400: return throwError(DataProtocol.BadRequestError.instanceJsonSerializer<TestRunProtocol.UpdateTestRunItemError>(TestRunProtocol.UpdateTestRunItemError).fromJson(response.error));
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(DataProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DbProtocol.TestRunItem.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public startTestRunItem(request: CommonProtocol.Empty, id: number): Observable<DbProtocol.TestRunItem> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .put(`${this.baseUrl}/api/test/run-items/${id}/start`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 400: return throwError(DataProtocol.BadRequestError.instanceJsonSerializer<TestRunProtocol.StartTestRunItemError>(TestRunProtocol.StartTestRunItemError).fromJson(response.error));
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(DataProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DbProtocol.TestRunItem.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public passTestRunItem(request: TestRunProtocol.FinishTestRunItemRequest, id: number): Observable<DbProtocol.TestRunItem> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .put(`${this.baseUrl}/api/test/run-items/${id}/pass`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 400: return throwError(DataProtocol.BadRequestError.instanceJsonSerializer<TestRunProtocol.FinishTestRunItemError>(TestRunProtocol.FinishTestRunItemError).fromJson(response.error));
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(DataProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DbProtocol.TestRunItem.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public failTestRunItem(request: TestRunProtocol.FinishTestRunItemRequest, id: number): Observable<DbProtocol.TestRunItem> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .put(`${this.baseUrl}/api/test/run-items/${id}/fail`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 400: return throwError(DataProtocol.BadRequestError.instanceJsonSerializer<TestRunProtocol.FinishTestRunItemError>(TestRunProtocol.FinishTestRunItemError).fromJson(response.error));
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(DataProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DbProtocol.TestRunItem.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public blockTestRunItem(request: TestRunProtocol.BlockTestRunItemRequest, id: number): Observable<DbProtocol.TestRunItem> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .put(`${this.baseUrl}/api/test/run-items/${id}/block`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 400: return throwError(DataProtocol.BadRequestError.instanceJsonSerializer<TestRunProtocol.BlockTestRunItemError>(TestRunProtocol.BlockTestRunItemError).fromJson(response.error));
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(DataProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DbProtocol.TestRunItem.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public reopenTestRunItem(request: CommonProtocol.Empty, id: number): Observable<DbProtocol.TestRunItem> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .put(`${this.baseUrl}/api/test/run-items/${id}/reopen`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 400: return throwError(DataProtocol.BadRequestError.instanceJsonSerializer<TestRunProtocol.ReopenTestRunItemError>(TestRunProtocol.ReopenTestRunItemError).fromJson(response.error));
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(DataProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DbProtocol.TestRunItem.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public deleteTestRunItem(id: number): Observable<DataProtocol.GenericResponse> {
        return this.http
            .delete(`${this.baseUrl}/api/test/run-items/${id}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(DataProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DataProtocol.GenericResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }
}
