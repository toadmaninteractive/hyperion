// Author: Igor compiler
// Compiler version: igorc 2.1.1
// DO NOT EDIT THIS FILE - it is machine generated

import { Injectable } from '@angular/core';
import { HttpClient, HttpErrorResponse, HttpHeaders } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { map, catchError } from 'rxjs/operators';
import * as Igor from './igor';
import * as DataProtocol from './data-protocol.data';
import * as DbProtocol from './db-protocol.data';
import * as JiraProtocol from './jira-protocol.data';

@Injectable({
    providedIn: 'root',
})
export class HyperionJiraService {
    public baseUrl = '';

    constructor(private http: HttpClient) { }

    public getJiraInstances(): Observable<DataProtocol.Collection<DbProtocol.JiraInstance>> {
        return this.http
            .get(`${this.baseUrl}/api/jira/instances`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DataProtocol.Collection.instanceJsonSerializer<DbProtocol.JiraInstance>(DbProtocol.JiraInstance).fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getJiraInstance(id: number): Observable<DbProtocol.JiraInstance> {
        return this.http
            .get(`${this.baseUrl}/api/jira/instances/${id}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(DataProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DbProtocol.JiraInstance.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public createJiraInstance(request: JiraProtocol.CreateJiraInstanceRequest): Observable<DbProtocol.JiraInstance> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .post(`${this.baseUrl}/api/jira/instances`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 400: return throwError(DataProtocol.BadRequestError.instanceJsonSerializer<JiraProtocol.JiraInstanceError>(JiraProtocol.JiraInstanceError).fromJson(response.error));
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DbProtocol.JiraInstance.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public updateJiraInstance(request: JiraProtocol.UpdateJiraInstanceRequest, id: number): Observable<DbProtocol.JiraInstance> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .put(`${this.baseUrl}/api/jira/instances/${id}`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 400: return throwError(DataProtocol.BadRequestError.instanceJsonSerializer<JiraProtocol.JiraInstanceError>(JiraProtocol.JiraInstanceError).fromJson(response.error));
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(DataProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DbProtocol.JiraInstance.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public deleteJiraInstance(id: number): Observable<DataProtocol.GenericResponse> {
        return this.http
            .delete(`${this.baseUrl}/api/jira/instances/${id}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 400: return throwError(DataProtocol.BadRequestError.instanceJsonSerializer<JiraProtocol.JiraInstanceError>(JiraProtocol.JiraInstanceError).fromJson(response.error));
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(DataProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DataProtocol.GenericResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public createJiraIssue(request: JiraProtocol.CreateJiraIssueRequest, testRunItemId: number): Observable<JiraProtocol.CreateJiraIssueResponse> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .post(`${this.baseUrl}/api/jira/issues/${testRunItemId}`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 400: return throwError(DataProtocol.BadRequestError.instanceJsonSerializer<JiraProtocol.JiraIssueError>(JiraProtocol.JiraIssueError).fromJson(response.error));
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(DataProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => JiraProtocol.CreateJiraIssueResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getAuthenticationStatus(jiraId: number): Observable<DataProtocol.GenericResponse> {
        return this.http
            .get(`${this.baseUrl}/api/jira/auth/${jiraId}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(DataProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DataProtocol.GenericResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public authenticate(request: JiraProtocol.AuthenticateJiraRequest, jiraId: number): Observable<DataProtocol.GenericResponse> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .post(`${this.baseUrl}/api/jira/auth/${jiraId}`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 400: return throwError(DataProtocol.BadRequestError.instanceJsonSerializer<JiraProtocol.JiraAuthenticationError>(JiraProtocol.JiraAuthenticationError).fromJson(response.error));
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(DataProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DataProtocol.GenericResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public revokeAuthentication(jiraId: number): Observable<DataProtocol.GenericResponse> {
        return this.http
            .delete(`${this.baseUrl}/api/jira/auth/${jiraId}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(DataProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DataProtocol.GenericResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }
}
