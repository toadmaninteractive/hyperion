// Author: Igor compiler
// Compiler version: igorc 2.1.1
// DO NOT EDIT THIS FILE - it is machine generated

import { Injectable } from '@angular/core';
import { HttpClient, HttpErrorResponse, HttpHeaders } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { map, catchError } from 'rxjs/operators';
import * as Igor from './igor';
import * as DbProtocol from './db-protocol.data';
import * as DataProtocol from './data-protocol.data';
import * as PersonnelProtocol from './personnel-protocol.data';

@Injectable({
    providedIn: 'root',
})
export class HyperionPersonnelService {
    public baseUrl = '';

    constructor(private http: HttpClient) { }

    public getPersonnelAccount(id: number): Observable<DbProtocol.PersonnelAccount> {
        return this.http
            .get(`${this.baseUrl}/api/admin/personnel/${id}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(DataProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DbProtocol.PersonnelAccount.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getPersonnelAccountByUsername(username: string): Observable<DbProtocol.PersonnelAccount> {
        return this.http
            .get(`${this.baseUrl}/api/admin/personnel/username/${username}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(DataProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DbProtocol.PersonnelAccount.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getPersonnelAccounts(needle: string | null = null, orderBy: PersonnelProtocol.PersonnelAccountOrderBy, orderDir: DataProtocol.OrderDirection, offset: number, limit: number): Observable<DataProtocol.CollectionSlice<DbProtocol.PersonnelAccount>> {
        const queryParams: Array<string> = [];
        if (needle != null)
            queryParams.push(`needle=${needle}`);
        queryParams.push(`order_by=${PersonnelProtocol.PersonnelAccountOrderBy.toJson(orderBy)}`);
        queryParams.push(`order_dir=${DataProtocol.OrderDirection.toJson(orderDir)}`);
        queryParams.push(`offset=${offset}`);
        queryParams.push(`limit=${limit}`);
        const queryString = queryParams.length > 0 ? `?${queryParams.join('&')}` : '';

        return this.http
            .get(`${this.baseUrl}/api/admin/personnels${queryString}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(DataProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DataProtocol.CollectionSlice.instanceJsonSerializer<DbProtocol.PersonnelAccount>(DbProtocol.PersonnelAccount).fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getPersonnelAccountRoles(id: number, needle: string | null = null, orderBy: PersonnelProtocol.PersonnelAccountRoleOrderBy, orderDir: DataProtocol.OrderDirection, offset: number, limit: number): Observable<DataProtocol.CollectionSlice<DbProtocol.PersonnelAccountRole>> {
        const queryParams: Array<string> = [];
        if (needle != null)
            queryParams.push(`needle=${needle}`);
        queryParams.push(`order_by=${PersonnelProtocol.PersonnelAccountRoleOrderBy.toJson(orderBy)}`);
        queryParams.push(`order_dir=${DataProtocol.OrderDirection.toJson(orderDir)}`);
        queryParams.push(`offset=${offset}`);
        queryParams.push(`limit=${limit}`);
        const queryString = queryParams.length > 0 ? `?${queryParams.join('&')}` : '';

        return this.http
            .get(`${this.baseUrl}/api/admin/personnel/${id}/roles${queryString}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(DataProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DataProtocol.CollectionSlice.instanceJsonSerializer<DbProtocol.PersonnelAccountRole>(DbProtocol.PersonnelAccountRole).fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getPersonnelAccountRolesForProject(id: number, needle: string | null = null, orderBy: PersonnelProtocol.PersonnelAccountRoleOrderBy, orderDir: DataProtocol.OrderDirection, offset: number, limit: number): Observable<DataProtocol.CollectionSlice<DbProtocol.PersonnelAccountRole>> {
        const queryParams: Array<string> = [];
        if (needle != null)
            queryParams.push(`needle=${needle}`);
        queryParams.push(`order_by=${PersonnelProtocol.PersonnelAccountRoleOrderBy.toJson(orderBy)}`);
        queryParams.push(`order_dir=${DataProtocol.OrderDirection.toJson(orderDir)}`);
        queryParams.push(`offset=${offset}`);
        queryParams.push(`limit=${limit}`);
        const queryString = queryParams.length > 0 ? `?${queryParams.join('&')}` : '';

        return this.http
            .get(`${this.baseUrl}/api/projects/${id}/roles/account${queryString}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(DataProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DataProtocol.CollectionSlice.instanceJsonSerializer<DbProtocol.PersonnelAccountRole>(DbProtocol.PersonnelAccountRole).fromJson(response as Igor.Json.JsonValue))
            );
    }

    public setPersonnelAccountRole(request: PersonnelProtocol.AccessRoleUpdateRequest, id: number, project: number): Observable<DataProtocol.GenericResponse> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .put(`${this.baseUrl}/api/admin/personnel/${id}/roles/${project}`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(DataProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DataProtocol.GenericResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public resetPersonnelAccountRole(id: number, project: number): Observable<DataProtocol.GenericResponse> {
        return this.http
            .delete(`${this.baseUrl}/api/admin/personnel/${id}/roles/${project}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(DataProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DataProtocol.GenericResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getPersonnelGroup(id: number): Observable<DbProtocol.PersonnelGroup> {
        return this.http
            .get(`${this.baseUrl}/api/admin/personnel-groups/${id}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(DataProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DbProtocol.PersonnelGroup.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getPersonnelGroupByName(name: string): Observable<DbProtocol.PersonnelGroup> {
        return this.http
            .get(`${this.baseUrl}/api/admin/personnel-groups/name/${name}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(DataProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DbProtocol.PersonnelGroup.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getPersonnelGroups(needle: string | null = null, orderBy: PersonnelProtocol.PersonnelGroupOrderBy, orderDir: DataProtocol.OrderDirection, offset: number, limit: number): Observable<DataProtocol.CollectionSlice<DbProtocol.PersonnelGroup>> {
        const queryParams: Array<string> = [];
        if (needle != null)
            queryParams.push(`needle=${needle}`);
        queryParams.push(`order_by=${PersonnelProtocol.PersonnelGroupOrderBy.toJson(orderBy)}`);
        queryParams.push(`order_dir=${DataProtocol.OrderDirection.toJson(orderDir)}`);
        queryParams.push(`offset=${offset}`);
        queryParams.push(`limit=${limit}`);
        const queryString = queryParams.length > 0 ? `?${queryParams.join('&')}` : '';

        return this.http
            .get(`${this.baseUrl}/api/admin/personnel-groups${queryString}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(DataProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DataProtocol.CollectionSlice.instanceJsonSerializer<DbProtocol.PersonnelGroup>(DbProtocol.PersonnelGroup).fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getPersonnelGroupRoles(id: number, needle: string | null = null, orderBy: PersonnelProtocol.PersonnelGroupRoleOrderBy, orderDir: DataProtocol.OrderDirection, offset: number, limit: number): Observable<DataProtocol.CollectionSlice<DbProtocol.PersonnelGroupRole>> {
        const queryParams: Array<string> = [];
        if (needle != null)
            queryParams.push(`needle=${needle}`);
        queryParams.push(`order_by=${PersonnelProtocol.PersonnelGroupRoleOrderBy.toJson(orderBy)}`);
        queryParams.push(`order_dir=${DataProtocol.OrderDirection.toJson(orderDir)}`);
        queryParams.push(`offset=${offset}`);
        queryParams.push(`limit=${limit}`);
        const queryString = queryParams.length > 0 ? `?${queryParams.join('&')}` : '';

        return this.http
            .get(`${this.baseUrl}/api/admin/personnel-groups/${id}/roles${queryString}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(DataProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DataProtocol.CollectionSlice.instanceJsonSerializer<DbProtocol.PersonnelGroupRole>(DbProtocol.PersonnelGroupRole).fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getPersonnelGroupRolesForProject(id: number, needle: string | null = null, orderBy: PersonnelProtocol.PersonnelGroupRoleOrderBy, orderDir: DataProtocol.OrderDirection, offset: number, limit: number): Observable<DataProtocol.CollectionSlice<DbProtocol.PersonnelGroupRole>> {
        const queryParams: Array<string> = [];
        if (needle != null)
            queryParams.push(`needle=${needle}`);
        queryParams.push(`order_by=${PersonnelProtocol.PersonnelGroupRoleOrderBy.toJson(orderBy)}`);
        queryParams.push(`order_dir=${DataProtocol.OrderDirection.toJson(orderDir)}`);
        queryParams.push(`offset=${offset}`);
        queryParams.push(`limit=${limit}`);
        const queryString = queryParams.length > 0 ? `?${queryParams.join('&')}` : '';

        return this.http
            .get(`${this.baseUrl}/api/admin/projects/${id}/roles/group${queryString}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(DataProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DataProtocol.CollectionSlice.instanceJsonSerializer<DbProtocol.PersonnelGroupRole>(DbProtocol.PersonnelGroupRole).fromJson(response as Igor.Json.JsonValue))
            );
    }

    public setPersonnelGroupRole(request: PersonnelProtocol.AccessRoleUpdateRequest, id: number, project: number): Observable<DataProtocol.GenericResponse> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .put(`${this.baseUrl}/api/admin/personnel-groups/${id}/roles/${project}`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(DataProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DataProtocol.GenericResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public resetPersonnelGroupRole(id: number, project: number): Observable<DataProtocol.GenericResponse> {
        return this.http
            .delete(`${this.baseUrl}/api/admin/personnel-groups/${id}/roles/${project}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(DataProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(DataProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(DataProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    throwError(response);
                }),
                map(response => DataProtocol.GenericResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }
}
