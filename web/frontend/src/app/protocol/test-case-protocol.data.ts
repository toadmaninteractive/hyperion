// Author: Igor compiler
// Compiler version: igorc 2.1.1
// DO NOT EDIT THIS FILE - it is machine generated

import * as Igor from './igor';
import * as DbProtocol from './db-protocol.data';

export class CreateTestCaseRequest {
    parentId?: number | null = null;
    preconditionId?: number | null = null;
    setupId?: number | null = null;
    isGroup!: boolean;
    title!: string;
    description?: string | null = null;
    testSteps!: string;
    expectedResult!: string;
    isDraft!: boolean;
    orderNum!: number;

    static fromJson(json: Igor.Json.JsonValue): CreateTestCaseRequest {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new CreateTestCaseRequest();
        obj.parentId = ('parent_id' in jsonObject && jsonObject['parent_id'] != null) ? jsonObject['parent_id'] as number : null;
        obj.preconditionId = ('precondition_id' in jsonObject && jsonObject['precondition_id'] != null) ? jsonObject['precondition_id'] as number : null;
        obj.setupId = ('setup_id' in jsonObject && jsonObject['setup_id'] != null) ? jsonObject['setup_id'] as number : null;
        obj.isGroup = jsonObject['is_group'] as boolean;
        obj.title = jsonObject['title'] as string;
        obj.description = ('description' in jsonObject && jsonObject['description'] != null) ? jsonObject['description'] as string : null;
        obj.testSteps = jsonObject['test_steps'] as string;
        obj.expectedResult = jsonObject['expected_result'] as string;
        obj.isDraft = jsonObject['is_draft'] as boolean;
        obj.orderNum = jsonObject['order_num'] as number;
        return obj;
    }

    static toJson(value: CreateTestCaseRequest): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        if (value.parentId != null) result['parent_id'] = value.parentId;
        if (value.preconditionId != null) result['precondition_id'] = value.preconditionId;
        if (value.setupId != null) result['setup_id'] = value.setupId;
        result['is_group'] = value.isGroup;
        result['title'] = value.title;
        if (value.description != null) result['description'] = value.description;
        result['test_steps'] = value.testSteps;
        result['expected_result'] = value.expectedResult;
        result['is_draft'] = value.isDraft;
        result['order_num'] = value.orderNum;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return CreateTestCaseRequest.toJson(this);
    }
}

export class UpdateTestCaseRequest {
    parentId?: number | null;
    preconditionId?: number | null;
    setupId?: number | null;
    title!: string;
    description!: string;
    testSteps!: string;
    expectedResult!: string;
    isDraft!: boolean;
    orderNum!: number;

    static fromJson(json: Igor.Json.JsonValue): UpdateTestCaseRequest {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new UpdateTestCaseRequest();
        if (jsonObject['parent_id'] !== undefined) obj.parentId = jsonObject['parent_id'] as number;
        if (jsonObject['precondition_id'] !== undefined) obj.preconditionId = jsonObject['precondition_id'] as number;
        if (jsonObject['setup_id'] !== undefined) obj.setupId = jsonObject['setup_id'] as number;
        if (jsonObject['title'] !== undefined) obj.title = jsonObject['title'] as string;
        if (jsonObject['description'] !== undefined) obj.description = jsonObject['description'] as string;
        if (jsonObject['test_steps'] !== undefined) obj.testSteps = jsonObject['test_steps'] as string;
        if (jsonObject['expected_result'] !== undefined) obj.expectedResult = jsonObject['expected_result'] as string;
        if (jsonObject['is_draft'] !== undefined) obj.isDraft = jsonObject['is_draft'] as boolean;
        if (jsonObject['order_num'] !== undefined) obj.orderNum = jsonObject['order_num'] as number;
        return obj;
    }

    static toJson(value: UpdateTestCaseRequest): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        if (value.parentId !== undefined) result['parent_id'] = value.parentId;
        if (value.preconditionId !== undefined) result['precondition_id'] = value.preconditionId;
        if (value.setupId !== undefined) result['setup_id'] = value.setupId;
        if (value.title !== undefined) result['title'] = value.title;
        if (value.description !== undefined) result['description'] = value.description;
        if (value.testSteps !== undefined) result['test_steps'] = value.testSteps;
        if (value.expectedResult !== undefined) result['expected_result'] = value.expectedResult;
        if (value.isDraft !== undefined) result['is_draft'] = value.isDraft;
        if (value.orderNum !== undefined) result['order_num'] = value.orderNum;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return UpdateTestCaseRequest.toJson(this);
    }
}

export enum TestCaseError {
    ParentNotExists = 1,
    ProjectNotExists = 2,
    PreconditionNotExists = 3,
    SetupNotExists = 4,
    TitleAlreadyExists = 5,
    HasChildren = 6,
}

export namespace TestCaseError {
    export function toJson(value: TestCaseError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): TestCaseError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: TestCaseError): Igor.Json.JsonValue {
        switch (value) {
            case TestCaseError.ParentNotExists: return 'parent_not_exists';
            case TestCaseError.ProjectNotExists: return 'project_not_exists';
            case TestCaseError.PreconditionNotExists: return 'precondition_not_exists';
            case TestCaseError.SetupNotExists: return 'setup_not_exists';
            case TestCaseError.TitleAlreadyExists: return 'title_already_exists';
            case TestCaseError.HasChildren: return 'has_children';
            default: throw new Error(`Invalid TestCaseError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): TestCaseError {
        switch (json) {
            case 'parent_not_exists': return TestCaseError.ParentNotExists;
            case 'project_not_exists': return TestCaseError.ProjectNotExists;
            case 'precondition_not_exists': return TestCaseError.PreconditionNotExists;
            case 'setup_not_exists': return TestCaseError.SetupNotExists;
            case 'title_already_exists': return TestCaseError.TitleAlreadyExists;
            case 'has_children': return TestCaseError.HasChildren;
            default: throw new Error(`Invalid TestCaseError value: ${json}`);
        }
    }
}

export class SpecializeTestCaseRequest {
    specType!: DbProtocol.SpecType;
    value?: string | null = null;
    parameterId?: number | null = null;

    static fromJson(json: Igor.Json.JsonValue): SpecializeTestCaseRequest {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new SpecializeTestCaseRequest();
        obj.specType = DbProtocol.SpecType.fromJson(jsonObject['spec_type']);
        obj.value = ('value' in jsonObject && jsonObject['value'] != null) ? jsonObject['value'] as string : null;
        obj.parameterId = ('parameter_id' in jsonObject && jsonObject['parameter_id'] != null) ? jsonObject['parameter_id'] as number : null;
        return obj;
    }

    static toJson(value: SpecializeTestCaseRequest): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['spec_type'] = DbProtocol.SpecType.toJson(value.specType);
        if (value.value != null) result['value'] = value.value;
        if (value.parameterId != null) result['parameter_id'] = value.parameterId;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return SpecializeTestCaseRequest.toJson(this);
    }
}

export enum TestCaseSpecializeError {
    TestCaseNotExists = 1,
    SetupStepNotAssigned = 2,
    SetupStepNotExists = 3,
    InvalidSetupStep = 4,
    ParameterlessSetupStep = 5,
    InvalidParameterValue = 6,
    InvalidParameterSource = 7,
}

export namespace TestCaseSpecializeError {
    export function toJson(value: TestCaseSpecializeError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): TestCaseSpecializeError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: TestCaseSpecializeError): Igor.Json.JsonValue {
        switch (value) {
            case TestCaseSpecializeError.TestCaseNotExists: return 'test_case_not_exists';
            case TestCaseSpecializeError.SetupStepNotAssigned: return 'setup_step_not_assigned';
            case TestCaseSpecializeError.SetupStepNotExists: return 'setup_step_not_exists';
            case TestCaseSpecializeError.InvalidSetupStep: return 'invalid_setup_step';
            case TestCaseSpecializeError.ParameterlessSetupStep: return 'parameterless_setup_step';
            case TestCaseSpecializeError.InvalidParameterValue: return 'invalid_parameter_value';
            case TestCaseSpecializeError.InvalidParameterSource: return 'invalid_parameter_source';
            default: throw new Error(`Invalid TestCaseSpecializeError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): TestCaseSpecializeError {
        switch (json) {
            case 'test_case_not_exists': return TestCaseSpecializeError.TestCaseNotExists;
            case 'setup_step_not_assigned': return TestCaseSpecializeError.SetupStepNotAssigned;
            case 'setup_step_not_exists': return TestCaseSpecializeError.SetupStepNotExists;
            case 'invalid_setup_step': return TestCaseSpecializeError.InvalidSetupStep;
            case 'parameterless_setup_step': return TestCaseSpecializeError.ParameterlessSetupStep;
            case 'invalid_parameter_value': return TestCaseSpecializeError.InvalidParameterValue;
            case 'invalid_parameter_source': return TestCaseSpecializeError.InvalidParameterSource;
            default: throw new Error(`Invalid TestCaseSpecializeError value: ${json}`);
        }
    }
}
