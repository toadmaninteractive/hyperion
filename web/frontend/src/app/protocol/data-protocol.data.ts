// Author: Igor compiler
// Compiler version: igorc 2.1.1
// DO NOT EDIT THIS FILE - it is machine generated

import * as Igor from './igor';

export enum OrderDirection {
    Asc = 1,
    Desc = 2,
}

export namespace OrderDirection {
    export function toJson(value: OrderDirection): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): OrderDirection {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: OrderDirection): Igor.Json.JsonValue {
        switch (value) {
            case OrderDirection.Asc: return 'asc';
            case OrderDirection.Desc: return 'desc';
            default: throw new Error(`Invalid OrderDirection value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): OrderDirection {
        switch (json) {
            case 'asc': return OrderDirection.Asc;
            case 'desc': return OrderDirection.Desc;
            default: throw new Error(`Invalid OrderDirection value: ${json}`);
        }
    }
}

export class Collection<T> {
    items!: Array<T>;

    static fromJson<T>(json: Igor.Json.JsonValue, t: Igor.Json.IJsonSerializer<T>): Collection<T> {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new Collection<T>();
        obj.items = Igor.Json.List(t).fromJson(jsonObject['items']);
        return obj;
    }

    static toJson<T>(value: Collection<T>, t: Igor.Json.IJsonSerializer<T>): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['items'] = Igor.Json.List(t).toJson(value.items);
        return result;
    }

    toJson(t: Igor.Json.IJsonSerializer<T>): Igor.Json.JsonValue {
        return Collection.toJson<T>(this, t);
    }

    static instanceJsonSerializer<T>(t: Igor.Json.IJsonSerializer<T>): Igor.Json.IJsonSerializer<Collection<T>> {
        return {
            toJson(value: Collection<T>): Igor.Json.JsonValue {
                return value.toJson(t);
            },

            fromJson(json: Igor.Json.JsonValue): Collection<T> {
                return Collection.fromJson<T>(json, t);
            }
        };
    }
}

export class CollectionSlice<T> {
    total!: number;
    items!: Array<T>;

    static fromJson<T>(json: Igor.Json.JsonValue, t: Igor.Json.IJsonSerializer<T>): CollectionSlice<T> {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new CollectionSlice<T>();
        obj.total = jsonObject['total'] as number;
        obj.items = Igor.Json.List(t).fromJson(jsonObject['items']);
        return obj;
    }

    static toJson<T>(value: CollectionSlice<T>, t: Igor.Json.IJsonSerializer<T>): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['total'] = value.total;
        result['items'] = Igor.Json.List(t).toJson(value.items);
        return result;
    }

    toJson(t: Igor.Json.IJsonSerializer<T>): Igor.Json.JsonValue {
        return CollectionSlice.toJson<T>(this, t);
    }

    static instanceJsonSerializer<T>(t: Igor.Json.IJsonSerializer<T>): Igor.Json.IJsonSerializer<CollectionSlice<T>> {
        return {
            toJson(value: CollectionSlice<T>): Igor.Json.JsonValue {
                return value.toJson(t);
            },

            fromJson(json: Igor.Json.JsonValue): CollectionSlice<T> {
                return CollectionSlice.fromJson<T>(json, t);
            }
        };
    }
}

export class TreeNode<T> {
    item?: T | null = null;
    children: Array<TreeNode<T>> = [];

    static fromJson<T>(json: Igor.Json.JsonValue, t: Igor.Json.IJsonSerializer<T>): TreeNode<T> {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new TreeNode<T>();
        obj.item = ('item' in jsonObject && jsonObject['item'] != null) ? t.fromJson(jsonObject['item']) : null;
        obj.children = ('children' in jsonObject && jsonObject['children'] != null) ? Igor.Json.List(TreeNode.instanceJsonSerializer<T>(t)).fromJson(jsonObject['children']) : [];
        return obj;
    }

    static toJson<T>(value: TreeNode<T>, t: Igor.Json.IJsonSerializer<T>): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        if (value.item != null) result['item'] = t.toJson(value.item);
        result['children'] = Igor.Json.List(TreeNode.instanceJsonSerializer<T>(t)).toJson(value.children);
        return result;
    }

    toJson(t: Igor.Json.IJsonSerializer<T>): Igor.Json.JsonValue {
        return TreeNode.toJson<T>(this, t);
    }

    static instanceJsonSerializer<T>(t: Igor.Json.IJsonSerializer<T>): Igor.Json.IJsonSerializer<TreeNode<T>> {
        return {
            toJson(value: TreeNode<T>): Igor.Json.JsonValue {
                return value.toJson(t);
            },

            fromJson(json: Igor.Json.JsonValue): TreeNode<T> {
                return TreeNode.fromJson<T>(json, t);
            }
        };
    }
}

export interface IResult {
    result: boolean;
}

export class GenericResponse implements IResult {
    result!: boolean;

    static fromJson(json: Igor.Json.JsonValue): GenericResponse {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new GenericResponse();
        obj.result = jsonObject['result'] as boolean;
        return obj;
    }

    static toJson(value: GenericResponse): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['result'] = value.result;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return GenericResponse.toJson(this);
    }
}

export class BadRequestError<T> {
    error!: T;

    static fromJson<T>(json: Igor.Json.JsonValue, t: Igor.Json.IJsonSerializer<T>): BadRequestError<T> {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new BadRequestError<T>();
        obj.error = t.fromJson(jsonObject['error']);
        return obj;
    }

    static toJson<T>(value: BadRequestError<T>, t: Igor.Json.IJsonSerializer<T>): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['error'] = t.toJson(value.error);
        return result;
    }

    toJson(t: Igor.Json.IJsonSerializer<T>): Igor.Json.JsonValue {
        return BadRequestError.toJson<T>(this, t);
    }

    static instanceJsonSerializer<T>(t: Igor.Json.IJsonSerializer<T>): Igor.Json.IJsonSerializer<BadRequestError<T>> {
        return {
            toJson(value: BadRequestError<T>): Igor.Json.JsonValue {
                return value.toJson(t);
            },

            fromJson(json: Igor.Json.JsonValue): BadRequestError<T> {
                return BadRequestError.fromJson<T>(json, t);
            }
        };
    }
}

export class ForbiddenError {
    static fromJson(json: Igor.Json.JsonValue): ForbiddenError {
        const obj = new ForbiddenError();
        return obj;
    }

    static toJson(value: ForbiddenError): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return ForbiddenError.toJson(this);
    }
}

export class NotFoundError {
    static fromJson(json: Igor.Json.JsonValue): NotFoundError {
        const obj = new NotFoundError();
        return obj;
    }

    static toJson(value: NotFoundError): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return NotFoundError.toJson(this);
    }
}

export class InternalServerError {
    error!: string;

    static fromJson(json: Igor.Json.JsonValue): InternalServerError {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new InternalServerError();
        obj.error = jsonObject['error'] as string;
        return obj;
    }

    static toJson(value: InternalServerError): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['error'] = value.error;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return InternalServerError.toJson(this);
    }
}
